/**************************************************************************
 
Name: Alexander Kellough            NetID: atk133

Program: Class-Project-Part-2       Class: CSE 4714

Description:
    The below file contains code describing a pparser/syntax analyzer
    for a subset of Pascal called TIPS>

***************************************************************************/
#ifdef _MSC_VER
#define _CRT_SECURE_NO_WARNINGS
#endif

#include <stdlib.h>
#include <string.h>
#include <iostream>
#include "lexer.h"
#include "parser.h"
#include "parse_tree_nodes.h"
 
using namespace std;

int nextToken = 0;            // hold nextToken returned by lex

// Which tree level are we currently in?  
static int level = 0;

vector<string> ids;
vector<string> types;

//*****************************************************************************
// Indent to reveal tree structure
string psp(void) { // Stands for p-space, but I want the name short
  string str("");
  for(int i = 0; i < level; i++)
    str += "|  ";
  return str;
}
//*****************************************************************************
// Report what we found
void output(string what) {
  cout << psp() << "found |" << yytext << "| " << what << endl;
}
//*****************************************************************************
// Forward declarations of FIRST_OF functions.  These check whether the current 
// token is in the FIRST set of a production rule.
BlockNode block();
void compound();
void statement();
void assignment();
void if_();
void while_();
void read();
void write();
void expression();
void simpleExp();
void term();
void factor();
bool first_of_program(void);
bool first_of_block(void);
bool first_of_compound(void);
bool first_of_statement(void);
bool first_of_assignment(void);
bool first_of_expression(void);
bool first_of_simpleExp(void);
bool first_of_term(void);
bool first_of_factor(void);
bool present(string str);
//*****************************************************************************
// Parses strings in the language generated by the rule:
// <program> â†’ TOK_PROGRAM TOK_IDENT TOK_SEMICOLON <block>
void program() 
{
    if (!first_of_program()) // Check for PROGRAM
        throw "3: 'PROGRAM' expected";
    
    output("PROGRAM");
    cout << psp() << "enter <program>" << endl;
    ++level;

    nextToken = yylex();

    if(nextToken != TOK_IDENT)
        throw "2: identifier expected";

    output("IDENTIFIER");
     
    nextToken = yylex();

    if(nextToken != TOK_SEMICOLON)
        throw "14: ';' expected";

    output("SEMICOLON");

    block();

    nextToken = yylex();

    --level;
    cout << psp() << "exit <program>" << endl;
    
}

// <block> => [VAR IDENTIFIER : (INTERGER | REAL); { IDENTIFIER : (INTEGER | REAL) }] <coumpound>
void block()
{
    bool duplicate = false;
    nextToken = yylex();
    if(!first_of_block())
        throw "18: error in declaration part OR 17: 'BEGIN' expected";

    output("BLOCK");

    cout << psp() << "enter <block>" << endl;
    ++level;
    
    if(nextToken == TOK_VAR)
    {
        nextToken = yylex();
        if(nextToken != TOK_IDENT)
            throw "2: identifier expected";
        
        while(nextToken == TOK_IDENT)
        {
            if(present(yytext))
                duplicate = true;

            ids.push_back(yytext);
            output("IDENTIFIER");

            nextToken = yylex();
            if(nextToken != TOK_COLON)
                throw "5: ':' expected";
            output("COLON");
            
            nextToken = yylex();
            if(nextToken != TOK_INTEGER && nextToken != TOK_REAL)
                throw "10: error in type";
            
            output("TYPE");

            types.push_back(yytext);

            nextToken = yylex();
            if(nextToken != TOK_SEMICOLON)
                throw "14: ';' expected";

            output("SEMICOLON");

            cout << psp() << "-- idName: |" << ids[ids.size() - 1] << "| idType: |" << types[types.size()-1]  << "| --" <<endl;

            if(duplicate)           // Checks that an identifier is not already declared
                throw "101: identifier declared twice";

            nextToken = yylex();
        }
    }

    compound();
    --level;
    cout << psp() << "exit <block>" << endl;
}

// <compound> => BEGIN <statement> {; <statement>} END 
void compound() 
{
    if(!first_of_compound())
        throw "17: 'BEGIN' expected";

    output("BEGIN");

    cout << psp() << "enter <compound_stmt>" << endl;
    ++level;
    do
    {
        nextToken = yylex();
        statement();
        if(nextToken == TOK_SEMICOLON)
            output("SEMICOLON");
    }
    while(nextToken == TOK_SEMICOLON); 

    --level;
    if(nextToken != TOK_END)
        throw "13: 'END' expected";
    output("END");
    nextToken = yylex();
    cout << psp() << "exit <compound_stmt>" << endl;
}

// <statement> => <assignment> | <compound> | <if> | <while> | <read> | <write>
void statement()
{
    if(!first_of_statement())
        throw "900: illegal type of statement";

    output("STATEMENT");

    if(nextToken == TOK_IDENT)
    {
        cout << psp() << "enter <assignment>" << endl;
        ++level;
        assignment();
        --level;
        cout << psp() << "exit <assignment>" << endl;
    }

    else if(nextToken == TOK_BEGIN)
    {
        compound();
    }

    else if(nextToken == TOK_IF)
    {
        cout << psp() << "enter <if>" << endl;
        ++level;
        if_();
        --level;
        cout << psp() << "exit <if>" << endl;
    }

    else if(nextToken == TOK_WHILE)
    {
        cout << psp() << "enter <while>" << endl;
        ++level;
        while_();
        --level;
        cout << psp() << "exit <while>" << endl;
    }

    else if(nextToken == TOK_READ)
    {
        cout << psp() << "enter <read>" << endl;
        ++level;
        read();
        --level;
        cout << psp() << "exit <read>" << endl;
    }

    else if(nextToken == TOK_WRITE)
    {
        cout << psp() << "enter <write>" << endl;
        ++level;
        write();
        --level;
        cout << psp() << "exit <write>" << endl;
    }
    else
        throw "999: an error has occurred";
}

// assignment => IDENTIFIER := <expression>
void assignment()
{
    if(!first_of_assignment())
        throw "2: identifier expected";

    output("IDENTIFIER");

    cout << psp() << yytext << endl;

    if(!present(yytext))
        throw "104: identifier not declared";

    nextToken = yylex();
    if(nextToken != TOK_ASSIGN)
        throw "51: ':=' expected"; 

    output("ASSIGN");

    nextToken = yylex();
    output("EXPRESSION");
    expression();
}

// <if> => IF <expression> THEN <statement> [ELSE <statement>]
void if_()
{
    nextToken = yylex();
    output("EXPRESSION");
    expression();

    if(nextToken != TOK_THEN)
        throw "52: 'THEN' expected";

    output("THEN");
    
    nextToken = yylex();
    statement();

    if(nextToken == TOK_ELSE)
    {
        --level;
        output("ELSE");
        cout << psp() << "enter <else>" << endl;
        ++level;
        nextToken = yylex();
        statement();
    }

}

// <while> => WHILE <expression> <statement>
void while_()
{
    nextToken = yylex();
    output("EXPRESSION");
    expression();
    statement();
}

// <read> => READ (IDENTIFIER)
void read()
{
    nextToken = yylex();
    if(nextToken != TOK_OPENPAREN)
        throw "9: '(' expected";
    output("OPENPAREN");

    nextToken = yylex();
    if(nextToken != TOK_IDENT)
        throw "2: identifier expected";

    output("IDENTIFIER");

    cout << psp() << yytext << endl;

    if(!present(yytext))
        throw "104: identifier not declared";

    nextToken = yylex();
    if(nextToken != TOK_CLOSEPAREN)
        throw "4: ')' expected";
    output("CLOSEPAREN");

    nextToken = yylex();
}

// <write> = WRITE (IDENTIFIER | STRING_LIT)
void write()
{
    nextToken = yylex();
    if(nextToken != TOK_OPENPAREN)
        throw "9: '(' expected";
    output("OPENPAREN");

    nextToken = yylex();
    if(nextToken != TOK_IDENT && nextToken != TOK_STRINGLIT)
        throw "134: illegal type of operand(s)";
    output("WRITE");

    cout << psp() << yytext << endl; 

    if(nextToken == TOK_IDENT)
    {
        if(!present(yytext))
             throw "104: identifier not declared";
    }

    nextToken = yylex();
    if(nextToken != TOK_CLOSEPAREN)
        throw "4: ')' expected";   
    output("CLOSEPAREN");

    nextToken = yylex();
}

// <expression> = <simple_exp> [= | > | < | <> <simple_exp>]
void expression()
{
    cout << psp() << "enter <expression>" << endl;
    ++level;

    if(!first_of_expression())
        throw "900: illegal type of statemen";

    output("SIMPLE_EXP");
    simpleExp();
    
    if(nextToken == TOK_EQUALTO || nextToken == TOK_LESSTHAN ||
    nextToken == TOK_GREATERTHAN || nextToken == TOK_NOTEQUALTO)
    {
        if(nextToken == TOK_EQUALTO)
            output("EQUALTO");

        if(nextToken == TOK_LESSTHAN)
            output("LESSTHAN");

        if(nextToken == TOK_GREATERTHAN)
            output("GREATERTHAN");

        if(nextToken == TOK_NOTEQUALTO)
            output("NOTEQUALTO");

        cout << psp() << yytext << endl;

        nextToken = yylex();
        output("SIMPLE_EXP");
        simpleExp(); 
    }

    --level;
    cout << psp() << "exit <expression>" << endl;
}

// <simple_exp> => <term> [+ | - | OR <term>] 
void simpleExp()
{
    cout << psp() << "enter <simple_exp>" << endl;
    ++level;
    if(!first_of_simpleExp())
        throw "901: illegal type of simple expression";

    output("TERM");
    term();

    if(nextToken == TOK_PLUS || nextToken == TOK_MINUS
    || nextToken == TOK_OR)
    {
        while(nextToken == TOK_PLUS || nextToken == TOK_MINUS
        || nextToken == TOK_OR)
        {
            if(nextToken == TOK_PLUS)
                output("PLUS");

            if(nextToken == TOK_MINUS)
                output("MINUS");

            if(nextToken == TOK_OR)
                output("OR");

            cout << psp() << yytext << endl;

            nextToken = yylex();
            output("TERM");
            term();
        }
    }

    --level;
    cout << psp() << "exit <simple_exp>" << endl;
}

// <term> => <factor> [* | / | AND <factor> ] 
void term()
{
    cout << psp() << "enter <term>" << endl;
    ++level;
    if(!first_of_term())
        throw "902: illegal type of term";

    output("FACTOR");
    factor();

    if(nextToken == TOK_MULTIPLY || nextToken == TOK_DIVIDE
    || nextToken == TOK_AND)
    {
        while(nextToken == TOK_MULTIPLY || nextToken == TOK_DIVIDE
        || nextToken == TOK_AND)    
        {
            if(nextToken == TOK_MULTIPLY)
                output("MULTIPLY");

            if(nextToken == TOK_DIVIDE)
                output("DIVIDE");

            if(nextToken == TOK_AND)
                output("AND");

            cout << psp() << yytext << endl;

            nextToken = yylex();
            output("FACTOR");
            factor();
        }
    }
    --level;
    cout << psp() << "exit <term>" << endl;
}

// <factor> => INTLIT | FLOATLIT | IDENTIFIER | (<expression>) | NOT <factor> | -<factor>
void factor()
{
    cout << psp() << "enter <factor>" << endl;
    ++level;

    if(!first_of_factor())
        throw "903: illegal type of factor";

    if(nextToken == TOK_INTLIT)
    {
        output("INTLIT");
        cout << psp() << yytext << endl;
    }

    if(nextToken == TOK_FLOATLIT)
    {
        output("FLOATLIT");
        cout << psp() << yytext << endl;
    }

    if(nextToken == TOK_IDENT)
    {
        output("IDENTIFIER");
        cout << psp() << yytext << endl;
        if(!present(yytext))
            throw "104: identifier not declared";
    }

    if(nextToken != TOK_OPENPAREN && nextToken != TOK_NOT
    && nextToken != TOK_MINUS)
    {
        nextToken = yylex();
        --level;
        cout << psp() << "exit <factor>" << endl;
        return;
    }

    if(nextToken == TOK_OPENPAREN)
    {
        output("OPENPAREN");
        cout << psp() << yytext << endl;
        nextToken = yylex();
        output("EXPRESSION");
        expression();
        if(nextToken != TOK_CLOSEPAREN)
            throw "4: ')' expected";

        output("CLOSEPAREN");

        nextToken = yylex();
    }

    else if(nextToken == TOK_NOT)
    {
        output("NOT");
        cout << psp() << yytext << endl;
        nextToken = yylex();
        output("FACTOR");
        factor();
    }
    else if(nextToken == TOK_MINUS)
    {
        output("MINUS");
        cout << psp() << yytext << endl;
        nextToken = yylex();
        output("FACTOR");
        factor();
    }

    else
        throw("999: an error has occurred");

    --level;
    cout << psp() << "exit <factor>" << endl;
}

bool first_of_factor(void)
{
    return nextToken == TOK_INTLIT || nextToken == TOK_FLOATLIT
    || nextToken == TOK_IDENT || nextToken == TOK_OPENPAREN ||
    nextToken == TOK_NOT || nextToken == TOK_MINUS;
}

bool first_of_expression(void)
{
    return first_of_factor();
}

bool first_of_simpleExp(void)
{
    return first_of_factor();
}

bool first_of_term(void)
{
    return first_of_factor();
}

bool first_of_assignment(void)
{
    return nextToken == TOK_IDENT;
}

bool first_of_statement(void)
{
    return nextToken == TOK_IDENT || nextToken == TOK_BEGIN || nextToken == TOK_IF || nextToken == TOK_WHILE
        || nextToken == TOK_READ || nextToken == TOK_WRITE;

}

bool first_of_compound(void)
{
    return nextToken == TOK_BEGIN;
}

bool first_of_block(void)
{
    return nextToken == TOK_VAR || nextToken == TOK_BEGIN;
}

bool first_of_program(void) {
    return nextToken == TOK_PROGRAM;
}

// Checks the presence of an identifier in the ids vector
bool present(string str)
{
    vector<string>::iterator it;
    for (it = ids.begin(); it != ids.end(); ++it) 
    {
        if(*it == str)
            return true;
    }          
    return false;
}

