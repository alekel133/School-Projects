/**************************************************************************
 
Name: Alexander Kellough            NetID: atk133

Program: Class-Project-Part-4      Class: CSE 4714

Description:
    The below file contains code describing a pparser/syntax analyzer
    for a subset of Pascal called TIPS>

***************************************************************************/
#ifdef _MSC_VER
#define _CRT_SECURE_NO_WARNINGS
#endif

#include <stdlib.h>
#include <string.h>
#include <iostream>
#include "parser.h"
#include "parse_tree_nodes.h"

 
using namespace std;

int nextToken = 0;            // hold nextToken returned by lex

bool printParse = false;

// Which tree level are we currently in?  
static int level = 0;

map<string, float> ids;
vector<string> types;

//*****************************************************************************
// Indent to reveal tree structure
string psp(void) { // Stands for p-space, but I want the name short
  string str("");
  for(int i = 0; i < level; i++)
    str += "|  ";
  return str;
}
//*****************************************************************************
// Report what we found
void output(string what) {
  cout << psp() << "found |" << yytext << "| " << what << endl;
}
//*****************************************************************************
// Forward declarations of FIRST_OF functions.  These check whether the current 
// token is in the FIRST set of a production rule.
BlockNode* block();
CompoundNode* compound();
StatementNode* statement();
AssignmentNode* assignment();
IfNode* if_();
WhileNode* while_();
ReadNode* read();
WriteNode* write();
ExprNode* expression();
SimpleExprNode* simpleExp();
TermNode* term();
FactorNode* factor();
bool first_of_program(void);
bool first_of_block(void);
bool first_of_compound(void);
bool first_of_statement(void);
bool first_of_assignment(void);
bool first_of_expression(void);
bool first_of_simpleExp(void);
bool first_of_term(void);
bool first_of_factor(void);
bool present(string str);
//*****************************************************************************
// Parses strings in the language generated by the rule:
// <program> â†’ TOK_PROGRAM TOK_IDENT TOK_SEMICOLON <block>
ProgramNode* program() 
{
    ProgramNode* pr;
    if (!first_of_program()) // Check for PROGRAM
        throw "3: 'PROGRAM' expected";
    
    if(printParse){
        output("PROGRAM");
        cout << psp() << "enter <program>" << endl;
    }
    ++level;

    nextToken = yylex();

    if(nextToken != TOK_IDENT)
        throw "2: identifier expected";

    if(printParse)
        output("IDENTIFIER");
     
    nextToken = yylex();

    if(nextToken != TOK_SEMICOLON)
        throw "14: ';' expected";

    if(printParse)
        output("SEMICOLON");

    pr = new ProgramNode(level, block());

    nextToken = yylex();

    --level;

    if(printParse)
        cout << psp() << "exit <program>" << endl;

    return pr;
    
}

// <block> => [VAR IDENTIFIER : (INTERGER | REAL); { IDENTIFIER : (INTEGER | REAL) }] <coumpound>
BlockNode* block()
{
    BlockNode* bl;
    string currId;
    bool duplicate = false;
    nextToken = yylex();
    if(!first_of_block())
        throw "18: error in declaration part OR 17: 'BEGIN' expected";

    if(printParse)
    {
        output("BLOCK");
        cout << psp() << "enter <block>" << endl;
    }

    ++level;
    
    if(nextToken == TOK_VAR)
    {
        nextToken = yylex();
        if(nextToken != TOK_IDENT)
            throw "2: identifier expected";
        
        while(nextToken == TOK_IDENT)
        {
            if(present(yytext))
                duplicate = true;

            ids.insert(pair<string, float>(yytext, 0));
            currId = yytext; 

            if(printParse)
                output("IDENTIFIER");

            nextToken = yylex();
            if(nextToken != TOK_COLON)
                throw "5: ':' expected";

            if(printParse)
                output("COLON");
            
            nextToken = yylex();
            if(nextToken != TOK_INTEGER && nextToken != TOK_REAL)
                throw "10: error in type";
            
            if(printParse)
                output("TYPE");

            types.push_back(yytext);
    
            nextToken = yylex();
            if(nextToken != TOK_SEMICOLON)
                throw "14: ';' expected";
            
            if(printParse)
            {
                output("SEMICOLON");
                cout << psp() << "-- idName: |" << currId << "| idType: |" << types[types.size()-1]  << "| --" <<endl;
            }

            if(duplicate)           // Checks that an identifier is not already declared
                throw "101: identifier declared twice";

            nextToken = yylex();
        }
    }

    bl = new BlockNode(level, compound());
    --level;

    if(printParse)
        cout << psp() << "exit <block>" << endl;

    return bl;
}

// <compound> => BEGIN <statement> {; <statement>} END 
CompoundNode* compound() 
{
    CompoundNode* cp;
    StatementNode* st;
    if(!first_of_compound())
        throw "17: 'BEGIN' expected";

    if(printParse)
    {
        output("BEGIN");
        cout << psp() << "enter <compound_stmt>" << endl;
    }

    ++level;
    cp = new CompoundNode(level);
    do
    {
        nextToken = yylex();
        cp->statementList.push_back(statement());
        if(nextToken == TOK_SEMICOLON)
        if(printParse)
            output("SEMICOLON");
    }
    while(nextToken == TOK_SEMICOLON); 

    --level;
    if(nextToken != TOK_END)
        throw "13: 'END' expected";

    if(printParse)
        output("END");

    nextToken = yylex();

    if(printParse)
        cout << psp() << "exit <compound_stmt>" << endl;

    return cp;
}

// <statement> => <assignment> | <compound> | <if> | <while> | <read> | <write>
StatementNode* statement()
{
    StatementNode* stmt;
    if(!first_of_statement())
        throw "900: illegal type of statement";

    if(printParse)
        output("STATEMENT");

    if(nextToken == TOK_IDENT)
    {
        if(printParse)
            cout << psp() << "enter <assignment>" << endl;

        ++level;
        stmt = assignment();
        --level;

        if(printParse)
            cout << psp() << "exit <assignment>" << endl;
    }

    else if(nextToken == TOK_BEGIN)
    {
        stmt = compound();
    }

    else if(nextToken == TOK_IF)
    {
        if(printParse)
            cout << psp() << "enter <if>" << endl;

        ++level;
        stmt = if_();
        --level;

        if(printParse)
            cout << psp() << "exit <if>" << endl;
    }

    else if(nextToken == TOK_WHILE)
    {
        if(printParse)
            cout << psp() << "enter <while>" << endl;

        ++level;
        stmt = while_();
        --level;

        if(printParse)
            cout << psp() << "exit <while>" << endl;
    }

    else if(nextToken == TOK_READ)
    {
        if(printParse)
            cout << psp() << "enter <read>" << endl;

        ++level;
        stmt = read();
        --level;

        if(printParse)
            cout << psp() << "exit <read>" << endl;
    }

    else if(nextToken == TOK_WRITE)
    {
        if(printParse)
            cout << psp() << "enter <write>" << endl;

        ++level;
        stmt = write();
        --level;

        if(printParse)
            cout << psp() << "exit <write>" << endl;
    }
    else
        throw "999: an error has occurred";

    return stmt;
}

// assignment => IDENTIFIER := <expression>
AssignmentNode* assignment()
{
    AssignmentNode* ass = new AssignmentNode(level);
    if(!first_of_assignment())
        throw "2: identifier expected";

    if(printParse)
    {
        output("IDENTIFIER");
        cout << psp() << yytext << endl;
    }

    if(!present(yytext))
        throw "104: identifier not declared";
    
    string* s = new string(yytext);
    ass->ident = s;

    nextToken = yylex();
    if(nextToken != TOK_ASSIGN)
        throw "51: ':=' expected"; 

    if(printParse)
        output("ASSIGN");

    nextToken = yylex();

    if(printParse)
        output("EXPRESSION");

    ass->exp = expression();
    return ass;
}

// <if> => IF <expression> THEN <statement> [ELSE <statement>]
IfNode* if_()
{
    IfNode* iff = new IfNode(level);
    nextToken = yylex();
    if(printParse)
        output("EXPRESSION");

    iff->ifExpression = expression();

    if(nextToken != TOK_THEN)
        throw "52: 'THEN' expected";

    if(printParse)
        output("THEN");
    
    nextToken = yylex();
    iff->thenStatement = statement();

    if(nextToken == TOK_ELSE)
    {
        --level;

        if(printParse)
        {
            output("ELSE");
            cout << psp() << "enter <else>" << endl;
        }

        ++level;
        nextToken = yylex();
        iff->elf=true;
        iff->elseStatement = statement();
    }
    return iff;
}

// <while> => WHILE <expression> <statement>
WhileNode* while_()
{
    WhileNode* wh = new WhileNode(level);
    nextToken = yylex();

    if(printParse)
        output("EXPRESSION");

    wh->cond = expression();
    wh->result = statement();
    return wh;
}

// <read> => READ (IDENTIFIER)
ReadNode* read()
{
    ReadNode* r;
    nextToken = yylex();
    if(nextToken != TOK_OPENPAREN)
        throw "9: '(' expected";

    if(printParse)
        output("OPENPAREN");

    nextToken = yylex();
    if(nextToken != TOK_IDENT)
        throw "2: identifier expected";

    if(printParse)
        output("IDENTIFIER");

    string* s = new string(yytext);
    r = new ReadNode(level, s);

    if(printParse)
        cout << psp() << yytext << endl;

    if(!present(yytext))
        throw "104: identifier not declared";

    nextToken = yylex();
    if(nextToken != TOK_CLOSEPAREN)
        throw "4: ')' expected";

    if(printParse)
        output("CLOSEPAREN");

    nextToken = yylex();
    return r;
}

// <write> = WRITE (IDENTIFIER | STRING_LIT)
WriteNode* write()
{
    WriteNode* w;
    nextToken = yylex();
    if(nextToken != TOK_OPENPAREN)
        throw "9: '(' expected";

    if(printParse)
        output("OPENPAREN");

    nextToken = yylex();
    if(nextToken != TOK_IDENT && nextToken != TOK_STRINGLIT)
        throw "134: illegal type of operand(s)";
    
    if(printParse)
    {
        output("WRITE");
        cout << psp() << yytext << endl; 
    }

    string* s = new string(yytext);
    w = new WriteNode(level, s);

    if(nextToken == TOK_IDENT)
    {
        if(!present(yytext))
             throw "104: identifier not declared";
    }

    nextToken = yylex();
    if(nextToken != TOK_CLOSEPAREN)
        throw "4: ')' expected";   
    
    if(printParse)
        output("CLOSEPAREN");

    nextToken = yylex();
    return w;
}

// <expression> = <simple_exp> [= | > | < | <> <simple_exp>]
ExprNode* expression()
{
    ExprNode* exp;

    if(printParse)
        cout << psp() << "enter <expression>" << endl;

    ++level;
    exp = new ExprNode(level);
    if(!first_of_expression())
        throw "900: illegal type of statement";

    if(printParse)
        output("SIMPLE_EXP");

    exp->firstSimpleExpr = simpleExp();
    
    if(nextToken == TOK_EQUALTO || nextToken == TOK_LESSTHAN ||
    nextToken == TOK_GREATERTHAN || nextToken == TOK_NOTEQUALTO)
    {
        if(nextToken == TOK_EQUALTO)
            if(printParse)
                output("EQUALTO");

        if(nextToken == TOK_LESSTHAN)
            if(printParse)
                output("LESSTHAN");

        if(nextToken == TOK_GREATERTHAN)
            if(printParse)
                output("GREATERTHAN");

        if(nextToken == TOK_NOTEQUALTO)
            if(printParse)
                output("NOTEQUALTO");

        exp->restSimpleExprOps.push_back(nextToken);

        if(printParse)
            cout << psp() << yytext << endl;

        nextToken = yylex();
        
        if(printParse)
            output("SIMPLE_EXP");

        exp->restSimpleExpr.push_back(simpleExp());
    }
    
    --level;

    if(printParse)
        cout << psp() << "exit <expression>" << endl;

    return exp;
}

// <simple_exp> => <term> [+ | - | OR <term>] 
SimpleExprNode* simpleExp()
{
    SimpleExprNode* s;

    if(printParse)
        cout << psp() << "enter <simple_exp>" << endl;

    ++level;
    s = new SimpleExprNode(level);
    if(!first_of_simpleExp())
        throw "901: illegal type of simple expression";

    if(printParse)
        output("TERM");

    s->firstTerm = term();

    if(nextToken == TOK_PLUS || nextToken == TOK_MINUS
    || nextToken == TOK_OR)
    {
        while(nextToken == TOK_PLUS || nextToken == TOK_MINUS
        || nextToken == TOK_OR)
        {
            if(nextToken == TOK_PLUS)
                if(printParse)
                    output("PLUS");

            if(nextToken == TOK_MINUS)
                if(printParse)
                    output("MINUS");

            if(nextToken == TOK_OR)
                if(printParse)
                    output("OR");

            s->restTermOps.push_back(nextToken);

            if(printParse)
                cout << psp() << yytext << endl;

            nextToken = yylex();

            if(printParse)
                output("TERM");

            s-> restTerms.push_back(term());
        }
    }

    --level;

    if(printParse)
        cout << psp() << "exit <simple_exp>" << endl;

    return s;
}

// <term> => <factor> [* | / | AND <factor> ] 
TermNode* term()
{
    TermNode *t;

    if(printParse)
        cout << psp() << "enter <term>" << endl;

    ++level;
    t = new TermNode(level);
    if(!first_of_term())
        throw "902: illegal type of term";

    if(printParse)
        output("FACTOR");

    t->firstFactor = factor();

    if(nextToken == TOK_MULTIPLY || nextToken == TOK_DIVIDE
    || nextToken == TOK_AND)
    {
        while(nextToken == TOK_MULTIPLY || nextToken == TOK_DIVIDE
        || nextToken == TOK_AND)    
        {
            if(nextToken == TOK_MULTIPLY)
                if(printParse)
                    output("MULTIPLY");

            if(nextToken == TOK_DIVIDE)
                if(printParse)
                    output("DIVIDE");

            if(nextToken == TOK_AND)
                if(printParse)
                    output("AND");
            
            t->restFactorOps.push_back(nextToken);

            if(printParse)
                cout << psp() << yytext << endl;

            nextToken = yylex();

            if(printParse)
                output("FACTOR");

            t->restFactors.push_back(factor());
        }
    }
    --level;

    if(printParse)
        cout << psp() << "exit <term>" << endl;

    return t;
}

// <factor> => INTLIT | FLOATLIT | IDENTIFIER | (<expression>) | NOT <factor> | -<factor>
FactorNode* factor()
{
    FactorNode* ret;

    if(printParse)
        cout << psp() << "enter <factor>" << endl;

    ++level;

    if(!first_of_factor())
        throw "903: illegal type of factor";

    if(nextToken == TOK_INTLIT)
    {
        if(printParse)
        {
            output("INTLIT");
            cout << psp() << yytext << endl;
        }

        int val = stoi(yytext);
        IntLitNode* intg = new IntLitNode(level, val);
        ret = intg;
    }

    if(nextToken == TOK_FLOATLIT)
    {
        if(printParse)
        {
            output("FLOATLIT");
            cout << psp() << yytext << endl;
        }

        FloatLitNode* flt = new FloatLitNode(level, stof(yytext));
        ret = flt;
    }

    if(nextToken == TOK_IDENT)
    {
        if(printParse)
        {
            output("IDENTIFIER");
            cout << psp() << yytext << endl;
        }

        if(!present(yytext))
            throw "104: identifier not declared";
        
        IdentNode* id = new IdentNode(level, yytext);
        ret = id;
    }

    if(nextToken != TOK_OPENPAREN && nextToken != TOK_NOT
    && nextToken != TOK_MINUS)
    {
        nextToken = yylex();
        --level;

        if(printParse)
            cout << psp() << "exit <factor>" << endl;

        return ret;
    }

    if(nextToken == TOK_OPENPAREN)
    {
        if(printParse)
        {
            output("OPENPAREN");
            cout << psp() << yytext << endl;
        }

        nextToken = yylex();

        if(printParse)
            output("EXPRESSION");

        NestedExprNode* nen = new NestedExprNode(level, expression());
        if(nextToken != TOK_CLOSEPAREN)
            throw "4: ')' expected";

        if(printParse)
            output("CLOSEPAREN");

        ret = nen;

        nextToken = yylex();
    }

    else if(nextToken == TOK_NOT)
    {
        if(printParse)
        {
            output("NOT");
            cout << psp() << yytext << endl;
        }

        nextToken = yylex();

        if(printParse)
            output("FACTOR");

        NotNode* no = new NotNode(level, factor());
        ret = no;
    }

    else if(nextToken == TOK_MINUS)
    {
        if(printParse)
        {
            output("MINUS");
            cout << psp() << yytext << endl;
        }

        nextToken = yylex();

        if(printParse)
            output("FACTOR");

        MinusNode* minus = new MinusNode(level, factor());
        ret = minus;
    }

    else
        throw("999: an error has occurred");

    --level;
    if(printParse)
        cout << psp() << "exit <factor>" << endl;

    return ret;
}

bool first_of_factor(void)
{
    return nextToken == TOK_INTLIT || nextToken == TOK_FLOATLIT
    || nextToken == TOK_IDENT || nextToken == TOK_OPENPAREN ||
    nextToken == TOK_NOT || nextToken == TOK_MINUS;
}

bool first_of_expression(void)
{
    return first_of_factor();
}

bool first_of_simpleExp(void)
{
    return first_of_factor();
}

bool first_of_term(void)
{
    return first_of_factor();
}

bool first_of_assignment(void)
{
    return nextToken == TOK_IDENT;
}

bool first_of_statement(void)
{
    return nextToken == TOK_IDENT || nextToken == TOK_BEGIN || nextToken == TOK_IF || nextToken == TOK_WHILE
        || nextToken == TOK_READ || nextToken == TOK_WRITE;

}

bool first_of_compound(void)
{
    return nextToken == TOK_BEGIN;
}

bool first_of_block(void)
{
    return nextToken == TOK_VAR || nextToken == TOK_BEGIN;
}

bool first_of_program(void) {
    return nextToken == TOK_PROGRAM;
}

// Checks the presence of an identifier in the ids vector
bool present(string str)
{
    map<string, float>::iterator it;
    for (it = ids.begin(); it != ids.end(); ++it) 
    {
        if(it->first == str)
            return true;
    }          
    return false;
}

